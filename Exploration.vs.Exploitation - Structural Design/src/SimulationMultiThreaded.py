import SimulationUtils
import simulate
import numpy
import logging
import csv
import time
import os
import Queue
import threading
import multiprocessing
import subprocess
import sys
import traceback

logger = logging.getLogger('Simulation')

# Set the log levels
logger.setLevel(logging.INFO)

queue = Queue.Queue()

def worker():
    logger.info("In worker! queue length "+str(queue.qsize()) )
    while True:
        sim = queue.get()
        try:
            sim.runSimulation()
        except:
            logger.error( "Unable to run simulation due to error:"+str(sys.exc_info()[0])) #+str(sys.exc_info()[0]) )               
            logger.error(traceback.format_exc())
        queue.task_done()
  

def startSimulation(m,n,s,pl,pt,pe,T,learnTMin,learnTMax,learnTInc,iterations,graphGenerator,dir,recordEachRun=False,runToConvergeLimit=False):
       
    for nIndex, nValue in enumerate(n):
        
        graph = graphGenerator.generateGraph(nValue)
        
        for mIndex, mValue in enumerate(m):            
            for sIndex, sValue in enumerate(s): 
                for plIndex, plValue in enumerate(pl):
                    for ptIndex, ptValue in enumerate(pt):
                        for peIndex, peValue in enumerate(pe):
                            logger.info("add to queue pt : "+str(ptValue) )
                            simDir = str(nValue)+"-"+str(mValue)+graphGenerator.graphFileInformation()
                            logger.info(simDir)
                            SimulationUtils.validateDir(dir+"/"+simDir)                            
                            queue.put( 
                                Simulation( nValue,mValue,sValue,plValue,ptValue,peValue,T,learnTMin,learnTMax,learnTInc,
                                        dir+"/"+simDir,graph,graphGenerator,iterations,recordEachRun,runToConvergeLimit) )

    # Run the number of cores
    # minus 1 so the system still functions
    cpus=multiprocessing.cpu_count()-1
    logger.info("Creating "+str(cpus)+" threads for queue length "+str(queue.qsize()) )
    for i in range(cpus):
        t = threading.Thread(target=worker)
        t.daemon = True
        t.start()        
               
    queue.join() #block until all tasks are done   
        
        
class Simulation:
    
    def __init__(self,n,m,s,pl,pt,pe,T,learnTMin,learnTMax,learnTInc,simDir,graph,graphGenerator,iterations,recordEachRun,runToConvergeLimit):
        self.n = n
        self.m = m
        self.s = s
        self.pl = pl
        self.pt = pt
        self.pe = pe
        self.T = T
        self.learnTMin = learnTMin
        self.learnTMax = learnTMax
        self.learnTInc = learnTInc
        self.simDir = simDir
        self.graph = graph
        self.graphGenerator = graphGenerator 
        self.iterations = iterations
        self.recordEachRun = recordEachRun
        self.runToConvergeLimit = runToConvergeLimit
        
        
    def runSimulation(self):
        
        for simCount in range(0,self.iterations):        

            reality = SimulationUtils.generateReality(self.m)                        
            # Randomly initalize the individuals with -1,0,1 as an n x m matrix
            individuals = numpy.random.randint(-1,2,size=(self.n,self.m))                                                
            logger.info(str(simCount+1)+" n: "+str(self.n)+" m: "+str(self.m)+" s: "+str(self.s)+" pl: "+str(self.pl)+" Graph Information: "+self.graphGenerator.graphInformation() )
            file = open(self.simDir+"/"+str(self.n)+"-"+str(self.m)+"-"+str(self.pt)+"-"+str(self.T)+"-"+str(self.pe)+"-"+self.graphGenerator.graphFileInformation()+"-simulation-"+str(time.time())+".csv", "ab") # opens the csv file
            writer = csv.writer(file, delimiter=',')                               
            simulate.simulate(self.graph, self.graphGenerator.graphData(), individuals, reality, self.pl, self.s, self.pt, self.pe, self.T, self.learnTMin, self.learnTMax, self.learnTInc, writer, self.recordEachRun,self.runToConvergeLimit)
            file.close()         
    
