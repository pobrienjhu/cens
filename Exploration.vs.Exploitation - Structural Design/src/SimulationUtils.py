import numpy
import logging
import random
import logging
import os


logger = logging.getLogger('SimulationUtils')

# Set the log levels
logger.setLevel(logging.INFO)


def validateDir(dirSt):
    dir = os.path.dirname(dirSt)
    if not os.path.exists(dirSt):
        os.makedirs(dirSt)

#
# find the dissimilatrity index as defined by Fang,Lee
#
def dissimularity(beliefs, m, n):
    
    #print("m = "+str(m)+"  n = "+str(n))
    
    dissimularity = findAllDissimularities(beliefs)
    
    dissimularity = float(2 * dissimularity) / (m * (n * (n-1)) )
    
    return dissimularity

#
# Find all the dissimalrities
#
def findAllDissimularities(beliefs):
    sumDiffCount = 0
    
    for i, beliefI in enumerate(beliefs):
        for j, beliefJ in enumerate(beliefs):
            if(j > i ):
                #logger.debug("beliefI "+str(beliefI)+" beliefJ "+str(beliefJ))
                sumDiffCount += findDifferenceCount(beliefI, beliefJ)
                #logger.debug("sumDiffCount is now "+str(sumDiffCount))
                
    return sumDiffCount

#
# Find a nodes neighbors with higher payoff
#
def findHigherPayoffs(beliefs, payoffs, neighbors, nodePayoff):
    
    #logger.debug( "beliefs "+str(beliefs) )
    #logger.debug( "payoffs"+str(payoffs) )
    #logger.debug( "neighbors "+str(neighbors) )
    #logger.debug( "nodePayoff "+str(nodePayoff) )

    higherLearners = list()
    
    #logger.debug("beliefs are "+str(beliefs))
    
    for index, neighbor in enumerate(neighbors):
        if payoffs[neighbor] > nodePayoff :
            #logger.debug("adding higher learner "+str(neighbor)+" beliefs len "+str(len(beliefs)))
            higherLearners.append(beliefs[neighbor])

    return higherLearners

#
# Fine Concensous from a list of beliefs
#
def findConcensous( beliefs ):
    
    #logger.debug("beliefs are "+str(beliefs))
    #logger.debug("belief type is |"+str(type(beliefs[0]))+"|")

    if(len(beliefs) == 0 ):
        return list()
    elif (type(beliefs[0]) == "<type 'numpy.int64'>" ):
        return beliefs
                    
    concensous = numpy.asarray(map(sum,zip(*beliefs)))  
    #logger.debug("initial concensous is "+str(concensous))                     
    concensous[concensous < 0] = -1
    concensous[concensous > 0] = 1
    
    return concensous

#
# Change Reality
#
def changeReality(reality, pe):
    
    if(pe == 0):
        return reality
    
    for index in range(0,len(reality)):
        if random.random() < pe:
            reality[index] *= -1

            
    return reality 
    
#
# Generate Turnover
#
def turnover(individuals, pt ):
    
    if(pt == 0):
        return individuals
    
    for index in range(0,len(individuals)):
        if random.random() < pt:
            individuals[index] = numpy.random.randint(-1,2,size=(1,len(individuals[index])))
    
    return individuals
              

#
# Change the beliefs of the learning belief to match that of the target belief
# with a probability of probabilityOfchange
#
def learn(student, teacher, probabilityOfChange ):
    #logger.debug( "student belief "+str(student) )
    #logger.debug( "teacher belief "+str(teacher) )
    #logger.debug( "probabilityOfChange "+str(probabilityOfChange))

    #create a copy of the original beliefs where the learning will take place. 
    learnedBeliefs = list(student)

    for index, belief in enumerate(student):
        #logger.debug( "index: "+str(index)+" student belief "+str(student[index])+" teacher belief is "+str(int(teacher[index])) )
        if( teacher[index] == 0 ): 
            continue
        elif ( student[index] != teacher[index] ) :
            if random.random() < probabilityOfChange:
                learnedBeliefs[index] = teacher[index]
                #logger.debug( "changing..." )
                #logger.debug( "learningBelief is "+str(learningBelief) )
                #logger.debug( "targetBelief is "+str(targetBelief) )
                #logger.debug( "learningBelief["+str(index)+"] is "+str(learningBelief[index]) )
                #logger.debug( "targetBelief["+str(index)+"] is "+str(targetBelief[index]) )
            #else:
                #logger.debug( "not Changing" )

    return numpy.asarray(learnedBeliefs)


#
# find all the payoffs for a list of individuals based on the degree of complexity
#
def findAllPayoffs(individuals, reality, degreeOfComplexity):
    individualPayoff = list()
    for index, individual in enumerate(individuals):
        individualPayoff.append( payoff(individual, reality, degreeOfComplexity) )
    return individualPayoff

#
# Find the differances between two beliefs
# ignore the differances if the first belief has a 0 (neutral) belief
#
def payoff(belief, reality, degreeOfComplexity):
    
    payoff = 0
    index = 0
    
    while index < len(belief):
        #print index, belief[index], reality[index]       
        if( belief[index] != reality[index] ):
            index = (((index) / degreeOfComplexity) + 1) * degreeOfComplexity
            continue
        
        if ((index+1) % degreeOfComplexity == 0 ):
            payoff += degreeOfComplexity
        
        index += 1
    
    return payoff
    
#
# rewire a given graph with the given probability 
#
def rewireGraph(probability, graph):
        
    nodes = list(range(graph.number_of_nodes())) # nodes are labeled 0 to n-1
    newGraph = graph;

    # rewire edges based on probability p
    # loop through the edges randomly chosing ones to rewire
    # do not allow self loops or duplicate edges
    for n1,n2,attr in graph.edges(data=True):
        if random.random() < probability:
            randNode = random.choice(nodes)
            
            # Enforce no self-loops or multiple edges
            while randNode == n2 or newGraph.has_edge(n1, randNode): 
                randNode = random.choice(nodes)
                
            newGraph.remove_edge(n1,n2)  
            newGraph.add_edge(n1,randNode)

    return newGraph
    
#
# find all teh differences between a list of individuals and reality
#
def findAllDifferences(individuals, reality):
    individualRealityDifferences = list()
    for index, individual in enumerate(individuals):
        individualRealityDifferences.append( findDifferenceCount(individual, reality) )
    return individualRealityDifferences
    
#
# Randomly initialize reality with values -1 or 1
#
def generateReality(m):
    externalReality = numpy.random.randint(0,2,m) #generates array of 0 and 1's
    externalReality[externalReality==0] = -1 # convert 0's to -1    
    return externalReality

#
# Randomly initialize reality with values -1 or 1
#
def generateIndividualsBeliefs(m):
    beliefs = numpy.random.randint(3,m) #generates array of 0's 1's and 2's
    beliefs[beliefs==2] = -1 # convert 2s to -1    
    return beliefs

#
# Find how similar two beliefs are
#
def findSimularitiesCount(belief1, belief2):
    return len(belief1) - findDifferenceCount(belief1, belief2)

#
# Find the differances between two beliefs
# ignore the differances if the first belief has a 0 (neutral) belief
#
def findDifferenceCount(belief1, belief2):
    
    diffrences = 0
    
    for count, belief in enumerate(belief1):
        if(belief1[count] != belief2[count]):
            diffrences = diffrences+1
    
    return diffrences
    
